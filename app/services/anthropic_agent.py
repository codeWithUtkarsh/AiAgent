from typing import List, Optional
from anthropic import Anthropic
from app.models import PackageInfo, PackageManager
from app.logger import get_logger

logger = get_logger(__name__)


class AnthropicAgent:
    """AI Agent using Anthropic's Claude for intelligent analysis"""

    def __init__(self, api_key: Optional[str], model: str = "claude-sonnet-4-5-20250929"):
        self.api_key = api_key
        self.model = model
        self.logger = logger
        self.client = None
        self.ai_enabled = False

        # Initialize client and check if AI is available
        try:
            if api_key and api_key != "your_anthropic_api_key_here":
                self.client = Anthropic(api_key=api_key)
                self.ai_enabled = True
                self.logger.info("Anthropic AI initialized successfully")
            else:
                self.logger.warning("Anthropic API key not configured. AI features will be disabled.")
        except Exception as e:
            self.logger.error(f"Failed to initialize Anthropic client: {e}")
            self.logger.warning("AI features will be disabled. Using fallback mode.")

    async def generate_pr_description(
        self,
        package_manager: PackageManager,
        outdated_packages: List[PackageInfo],
        update_output: str
    ) -> str:
        """
        Generate a comprehensive PR description using Claude

        Args:
            package_manager: Package manager used
            outdated_packages: List of outdated packages
            update_output: Output from package update command

        Returns:
            Generated PR description in markdown format
        """
        # If AI is not enabled, use fallback immediately
        if not self.ai_enabled or not self.client:
            self.logger.info("AI not available, using fallback PR description")
            return self._generate_fallback_description(package_manager, outdated_packages)

        self.logger.info("Generating PR description using Claude")

        try:
            # Prepare package information
            packages_info = "\n".join([
                f"- {pkg.name}: {pkg.current_version} → {pkg.latest_version}"
                for pkg in outdated_packages
            ])

            prompt = f"""You are a helpful AI assistant that generates clear and concise pull request descriptions for dependency updates.

Task: Generate a professional pull request description for updating dependencies in a {package_manager.value} project.

Updated Packages ({len(outdated_packages)} total):
{packages_info}

Update Command Output:
{update_output[:1000]}

Please generate a PR description that includes:
1. A clear title summarizing the updates
2. A brief summary of what was updated
3. The list of package updates with version changes
4. Any important notes or breaking changes (if obvious from version jumps)
5. Testing recommendations

Format the response in markdown. Keep it professional and concise."""

            message = self.client.messages.create(
                model=self.model,
                max_tokens=2000,
                messages=[
                    {
                        "role": "user",
                        "content": prompt
                    }
                ]
            )

            # Extract text from response
            description = ""
            for block in message.content:
                if hasattr(block, 'text'):
                    description += block.text

            self.logger.info("Successfully generated PR description")
            return description

        except Exception as e:
            self.logger.error(f"Error generating PR description: {e}")
            # Return a fallback description
            return self._generate_fallback_description(
                package_manager,
                outdated_packages
            )

    def _generate_fallback_description(
        self,
        package_manager: PackageManager,
        outdated_packages: List[PackageInfo]
    ) -> str:
        """Generate a basic fallback description if AI fails"""

        packages_list = "\n".join([
            f"- `{pkg.name}`: `{pkg.current_version}` → `{pkg.latest_version}`"
            for pkg in outdated_packages
        ])

        return f"""# Dependency Updates

## Summary
This PR updates {len(outdated_packages)} dependencies in the {package_manager.value} project to their latest versions.

## Updated Packages
{packages_list}

## Testing Recommendations
- Verify all existing tests pass
- Check for any breaking changes in the updated packages
- Review the changelog of major version updates

---
*This PR was automatically generated by AI Agent*
"""

    async def analyze_package_updates(
        self,
        package_manager: PackageManager,
        outdated_packages: List[PackageInfo]
    ) -> str:
        """
        Analyze package updates and provide insights

        Args:
            package_manager: Package manager type
            outdated_packages: List of outdated packages

        Returns:
            Analysis summary
        """
        # If AI is not enabled, use simple summary
        if not self.ai_enabled or not self.client:
            self.logger.info("AI not available, using basic analysis")
            return f"Found {len(outdated_packages)} packages to update. Review changes carefully before merging."

        self.logger.info("Analyzing package updates using Claude")

        try:
            packages_info = "\n".join([
                f"- {pkg.name}: {pkg.current_version} → {pkg.latest_version}"
                for pkg in outdated_packages
            ])

            prompt = f"""Analyze these package updates for a {package_manager.value} project and provide a brief summary:

{packages_info}

Please identify:
1. Any major version updates (potential breaking changes)
2. Security updates (if version numbers suggest it)
3. Overall risk level (Low/Medium/High)
4. Key recommendations

Keep the response brief and actionable."""

            message = self.client.messages.create(
                model=self.model,
                max_tokens=1000,
                messages=[
                    {
                        "role": "user",
                        "content": prompt
                    }
                ]
            )

            # Extract text from response
            analysis = ""
            for block in message.content:
                if hasattr(block, 'text'):
                    analysis += block.text

            self.logger.info("Successfully analyzed package updates")
            return analysis

        except Exception as e:
            self.logger.error(f"Error analyzing package updates: {e}")
            return f"Found {len(outdated_packages)} packages to update. Review changes carefully."

    async def generate_commit_message(
        self,
        package_manager: PackageManager,
        outdated_packages: List[PackageInfo]
    ) -> str:
        """
        Generate a commit message for the updates

        Args:
            package_manager: Package manager type
            outdated_packages: List of outdated packages

        Returns:
            Commit message
        """
        try:
            packages_list = ", ".join([pkg.name for pkg in outdated_packages[:5]])
            if len(outdated_packages) > 5:
                packages_list += f" and {len(outdated_packages) - 5} more"

            return f"chore: update {package_manager.value} dependencies\n\nUpdate {packages_list}"

        except Exception as e:
            self.logger.error(f"Error generating commit message: {e}")
            return f"chore: update {package_manager.value} dependencies"
